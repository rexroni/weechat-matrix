#!/usr/bin/python3 -u
# Copyright © 2019 Damir Jelić <poljar@termina.org.uk>
#
# Permission to use, copy, modify, and/or distribute this software for
# any purpose with or without fee is hereby granted, provided that the
# above copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""
Webrtc client transporting the signaling over stdin/stdout.

gstwebrtc example code:
 - blog.nirbheek.in/2018/02/gstreamer-webrtc.html
 - github.com/centricular/gstwebrtc-demos
 - github.com/GStreamer/gst-plugins-bad/tree/master/tests/examples/webrtc

gstreamer examples:
 - wiki.oz9aec.net/index.php?title=Gstreamer_Cheat_Sheet
"""

import os
import sys
import json
import signal
import argparse
import asyncio

import gi
import gbulb

gi.require_version('Gtk', '3.0')
from gi.repository import Gtk
gi.require_version('Gst', '1.0')
from gi.repository import Gst
gi.require_version('GstWebRTC', '1.0')
from gi.repository import GstWebRTC
gi.require_version('GstSdp', '1.0')
from gi.repository import GstSdp

asyncio.set_event_loop_policy(gbulb.GLibEventLoopPolicy())

PIPELINE_DESC = """
webrtcbin name=sendrecv bundle-policy=max-bundle
    videotestsrc is-live=true pattern=ball ! videoconvert ! queue !
        vp8enc deadline=1 ! rtpvp8pay ! queue !
         application/x-rtp,media=video,encoding-name=VP8,payload=97 ! sendrecv.
    audiotestsrc is-live=true wave=red-noise ! audioconvert ! audioresample !
        queue ! opusenc ! rtpopuspay ! queue !
        application/x-rtp,media=audio,encoding-name=OPUS,payload=96 ! sendrecv.
"""
PIPELINE_DESC = """
webrtcbin name=sendrecv bundle-policy=max-bundle
    audiotestsrc is-live=true wave=red-noise ! audioconvert ! audioresample !
        queue ! opusenc ! rtpopuspay ! queue !
        application/x-rtp,media=audio,encoding-name=OPUS,payload=96 ! sendrecv.
"""


class IceCandidate:
    def __init__(self, candidate: str, sdpMLineIndex: int, sdpMid=None):
        self.candidate = candidate
        self.sdpMLineIndex = sdpMLineIndex
        self.sdpMid = sdpMid


def object_from_string(message_str):
    try:
        message = json.loads(message_str)
    except json.decoder.JSONDecodeError:
        return

    if message["type"] in ["answer", "offer"]:
        msg_type = (GstWebRTC.WebRTCSDPType.ANSWER
                    if message["type"] == "answer" else
                    GstWebRTC.WebRTCSDPType.OFFER)

        res, sdpmsg = GstSdp.SDPMessage.new()
        GstSdp.sdp_message_parse_buffer(bytes(message["sdp"].encode()), sdpmsg)

        return GstWebRTC.WebRTCSessionDescription.new(msg_type, sdpmsg)

    elif message["type"] == "candidate":
        candidate = IceCandidate(
            message["candidate"],
            message["sdpMLineIndex"],
            message.get("sdpMid", None)
        )
        return candidate

    else:
        print("unknown object", file=sys.stderr)


def object_to_string(obj):
    if isinstance(obj, GstWebRTC.WebRTCSessionDescription):
        message = {
            "sdp": obj.sdp.as_text(),
            "type": GstWebRTC.WebRTCSDPType.to_string(obj.type)
        }

    elif isinstance(obj, IceCandidate):
        message = {
            "candidate": obj.candidate,
            "sdpMLineIndex": obj.sdpMLineIndex,
            "type": "candidate",
        }

        if obj.sdpMid:
            message["sdpMid"] = obj.sdpMid

    return json.dumps(message, sort_keys=True)


class StinStdoutSignaling:
    def __init__(self):
        self._read_pipe = os.sys.stdin
        self._read_transport = None
        self._reader = None
        self._write_pipe = os.sys.stdout

    async def _connect(self):
        if self._reader is not None:
            return

        loop = asyncio.get_event_loop()
        self._reader = asyncio.StreamReader(loop=loop)
        self._read_transport, _ = await loop.connect_read_pipe(
            lambda: asyncio.StreamReaderProtocol(self._reader),
            self._read_pipe)

    async def close(self):
        if self._reader is not None:
            self._read_transport.close()
            self._reader = None

    async def receive(self):
        await self._connect()
        data = await self._reader.readline()
        return object_from_string(data.decode(self._read_pipe.encoding))

    async def send(self, obj):
        self._write_pipe.write(object_to_string(obj) + "\n")


class PromiseError(Exception):
    pass


def get_promise_reply(promise):
    """
    Raise an error if the promise is broken, otherwise return the reply.
    """
    if promise.wait() != Gst.PromiseResult.REPLIED:
        raise PromiseError("promise not in REPLIED state")

    return promise.get_reply()


def printonly_promise(msg):
    """
    Return a promise which only prints a message upon completion
    """

    def _done_func(promise, _, __):
        _ = get_promise_reply(promise)
        print(msg, file=sys.stderr)

    return Gst.Promise.new_with_change_func(_done_func, None, None)


def printonly_sighandler(msg):
    """
    Return a closure that just prints a message when a signal is received.
    """

    def _sighandler_func(*_, **__):
        print(msg, file=sys.stderr)

    return _sighandler_func


def print_webrtc_state(w):
    # property list: gstreamer.freedesktop.org/documentation/webrtc/index.html
    props = [
#       'async-handling',
#       'bundle-policy',
        'connection-state',
#       'current-local-description',
#       'current-remote-description',
#       'ice-connection-state',
#       'ice-gathering-state',
#       'ice-transport-policy',
#       'local-description',
#       'message-forward',
#       'name',
#       'parent',
#       'pending-local-description',
#       'remote-description',
        'signaling-state',
#       'stun-server',
        'turn-server',
    ]

    print('\n'.join(
        ['%- 27s: %s'%(p, w.get_property(p)) for p in props]
    ), file=sys.stderr)


class WebRTCClient(Gtk.Box):
    def __init__(self, role):
        super().__init__()

        self.role = role

        self.signaling = StinStdoutSignaling()
        self.pipe = Gst.parse_launch(PIPELINE_DESC)

        self.webrtc = self.pipe.get_by_name('sendrecv')

        # in the examples, on-negotiation-needed is only used by the offerer
        # (github.com/GStreamer/gst-plugins-bad/tree/master/tests/examples/webrtc)
        if role == 'offer':
            self.webrtc.connect('on-negotiation-needed', self.on_negotiation_needed)

        self.webrtc.connect('on-ice-candidate', self.send_ice_candidate_message)
        self.webrtc.connect('pad-added', self.on_incoming_stream)

        # signal list: gstreamer.freedesktop.org/documentation/webrtc/index.html
        signals = [
            # 'on-negotiation-needed',
            'on-data-channel',
            'on-new-transceiver',
            'no-more-pads',
        ]
        # some debug hooks to try to figure out what we are missing:
        for s in signals:
            func = lambda *_: print('ignoring '+s, file=sys.stderr)
            self.webrtc.connect(s, func)

        self.bin = Gst.parse_bin_from_description("videotestsrc", True)
        self.connect('realize', self._on_realize)
        self.sink = None

    def _on_realize(self, widget):
        print("on realize", file=sys.stderr)
        factory = self.pipe.get_factory()
        gtksink = factory.make('gtksink')
        self.pack_start(gtksink.props.widget, True, True, 0)
        gtksink.props.widget.show()
        self.sink = gtksink

    def on_offer_created(self, promise, _, __):
        reply = get_promise_reply(promise)
        offer = reply.get_value('offer')
        print("offer created", file=sys.stderr)

        promise = printonly_promise("local_description_set (after offer)")
        print("emit set-local-description", file=sys.stderr)
        self.webrtc.emit('set-local-description', offer, promise)

        loop = asyncio.new_event_loop()
        loop.run_until_complete(self.signaling.send(offer))

    def on_negotiation_needed(self, _):
        print('on_negotiation_needed', file=sys.stderr)
        promise = Gst.Promise.new_with_change_func(
            self.on_offer_created,
            None,
            None,
        )
        print("emit create-offer", file=sys.stderr)
        self.webrtc.emit('create-offer', None, promise)

    def on_local_descr(self, promise, _, __):
        print("on_local_descr", file=sys.stderr)
        _ = get_promise_reply(promise)

        # print state after setting local description to show we are at STABLE
        print_webrtc_state(self.webrtc)

    def on_answer_create(self, promise, _, __):
        print("on_answer_create", file=sys.stderr)
        reply = get_promise_reply(promise)
        answer = reply.get_value("answer")

        # print state before setting local description
        print_webrtc_state(self.webrtc)

        # promise = printonly_promise("local_description_set (after answer)")
        promise = Gst.Promise.new_with_change_func(self.on_local_descr, None, None)
        self.webrtc.emit('set-local-description', answer, promise)

        loop = asyncio.new_event_loop()
        loop.run_until_complete(self.signaling.send(answer))

    def send_answer(self):
        promise = Gst.Promise.new_with_change_func(
            self.on_answer_create,
            None,
            None,
        )
        print("emit create-answer", file=sys.stderr)
        self.webrtc.emit('create-answer', None, promise)

    def on_remote_description_set(self, promise, message, __):
        _ = get_promise_reply(promise)
        print("on_remote_description_set", file=sys.stderr)

        if message.type == GstWebRTC.WebRTCSDPType.OFFER:
            self.send_answer()

    def send_ice_candidate_message(self, _, mlineindex, candidate):
        # (noisy)
        # print("ice_candidate: "+str(candidate), file=sys.stderr)
        candidate = IceCandidate(candidate, mlineindex)
        loop = asyncio.new_event_loop()
        loop.run_until_complete(self.signaling.send(candidate))

    def on_incoming_decodebin_stream(self, _, pad):
        print("on_incoming_decodebin_stream", file=sys.stderr)

        if not pad.has_current_caps():
            return

        caps = pad.get_current_caps()

        if not caps:
            return

        s = caps.get_structure(0)
        name = s.get_name()

        if name.startswith('video'):
            print("video", file=sys.stderr)
            q = Gst.ElementFactory.make('queue')
            conv = Gst.ElementFactory.make('videoconvert')

            self.pipe.add(q)
            self.pipe.add(conv)
            self.pipe.add(self.sink)
            self.pipe.sync_children_states()

            pad.link(q.get_static_pad('sink'))
            q.link(conv)
            conv.link(self.sink)

        elif name.startswith('audio'):
            print("audio", file=sys.stderr)
            q = Gst.ElementFactory.make('queue')
            conv = Gst.ElementFactory.make('audioconvert')
            resample = Gst.ElementFactory.make('audioresample')
            sink = Gst.ElementFactory.make('autoaudiosink')

            self.pipe.add(q, conv, resample, sink)
            self.pipe.sync_children_states()

            pad.link(q.get_static_pad('sink'))
            q.link(conv)
            conv.link(resample)
            resample.link(sink)

    def on_incoming_stream(self, _, pad):
        print('on_incoming_stream', file=sys.stderr)
        if pad.direction != Gst.PadDirection.SRC:
            return

        decodebin = Gst.ElementFactory.make('decodebin')
        decodebin.connect('pad-added', self.on_incoming_decodebin_stream)

        self.pipe.add(decodebin)
        decodebin.sync_state_with_parent()
        self.webrtc.link(decodebin)

    def start_pipeline(self):
        self.pipe.set_state(Gst.State.PLAYING)

    async def loop(self):
        if self.role == "offer":
            self.start_pipeline()

        while True:
            message = await self.signaling.receive()

            if isinstance(message, GstWebRTC.WebRTCSessionDescription):

                if message.type == GstWebRTC.WebRTCSDPType.OFFER:
                    self.start_pipeline()

                # try setting the turn server
                usr='turnuser'
                pwd='turnpass'
                srv='turn.server.com'
                port='3478'
                trans='transport=udp'
                uri=f"turn://{usr}:{pwd}@{srv}:{port}?{trans}"
                self.webrtc.set_property("turn-server", uri)

                promise = Gst.Promise.new_with_change_func(
                    self.on_remote_description_set,
                    message,
                    None,
                )
                print("emit set-remote-description", file=sys.stderr)
                self.webrtc.emit(
                    'set-remote-description',
                    message,
                    promise,
                )

            elif isinstance(message, IceCandidate):
                self.webrtc.emit(
                    'add-ice-candidate',
                    message.sdpMLineIndex,
                    message.candidate,
                )

            else:
                print('unknown message', file=sys.stderr)

        return 0


def check_plugins():
    needed = ["opus", "vpx", "nice", "webrtc", "dtls", "srtp", "rtp",
              "rtpmanager", "videotestsrc", "audiotestsrc"]
    missing = list(
        filter(lambda p: Gst.Registry.get().find_plugin(p) is None, needed)
    )
    if len(missing):
        print('Missing gstreamer plugins:', missing, file=sys.stderr)
        return False
    return True


def quit_handler(signum, frame):
    loop = asyncio.get_event_loop()
    loop.stop()


if __name__=='__main__':
    Gst.init(None)

    if not check_plugins():
        sys.exit(1)

    parser = argparse.ArgumentParser(
        description="Video stream from the command line"
    )
    parser.add_argument("role", choices=["offer", "answer"])

    args = parser.parse_args()

    client = WebRTCClient(args.role)
    window = Gtk.ApplicationWindow(title="Simple WebRTC client")

    hangup = Gtk.Button.new_from_icon_name("call-stop", 6)
    microphone = Gtk.Button.new_from_icon_name("audio-input-microphone", 6)
    camera = Gtk.Button.new_from_icon_name("camera-web", 6)

    buttonbox = Gtk.HBox()
    buttonbox.add(camera)
    buttonbox.add(microphone)
    buttonbox.add(hangup)

    box = Gtk.VBox()
    box.pack_start(client, True, True, 0)
    box.pack_start(buttonbox, False, False, 0)

    window.add(box)

    window.show_all()

    signal.signal(signal.SIGQUIT, quit_handler)

    def on_destroy(win):
        loop = asyncio.get_event_loop()
        loop.close

    window.connect('destroy', on_destroy)
    loop = asyncio.get_event_loop()

    try:
        res = loop.run_until_complete(client.loop())
    finally:
        loop.close()

    sys.exit(res)
